import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import os
# Removed Spline import
# import statsmodels.api as sm # Option 1
from statsmodels.nonparametric.smoothers_lowess import lowess # Option 2

# --- Configuration ---
TLE_DATA_FOLDER = '/Users/suryatejachalla/Research/Re-entry-Prediction/Code/Orbital-Influence/tle_data_output'
# *** Point to the ML data generated by the LOESS script ***
ML_DATA_FILE = '/Users/suryatejachalla/Research/Re-entry-Prediction/Code/Orbital-Influence/ml_ready_data_loess.csv' # <--- UPDATED

PARAMS_TO_PLOT = ['AltitudePerigee_km', 'SemiMajorAxis_km', 'Period_sec', 'MeanMotion_revday', 'ndot_TERM_from_TLE', 'Bstar', 'Inclination_deg']

# --- Match the settings used in loess_feature_extractor.py ---
# *** THESE VALUES MUST MATCH the LOESS_FRAC and LOESS_ITER used in your feature extractor script ***
LOESS_FRAC = 0.25
LOESS_ITER = 3
# Minimum points required for plotting (should match extractor)
MIN_DATA_POINTS_FOR_PLOT = 10

# --- Renamed Function ---
def plot_loess_fit_vs_original_separate(norad_id_str):
    """
    Loads data for a given NORAD ID and plots original data vs fitted LOESS curve
    in separate windows for each parameter. Re-fits the LOESS curve for plotting.
    """
    try:
        norad_id = int(norad_id_str)
    except ValueError:
        print(f"Error: Invalid NORAD ID '{norad_id_str}'. Please enter a number.")
        return

    # --- Load ML Ready Data (Optional - mainly for residual info in title) ---
    satellite_features = None
    try:
        # Use the updated ML_DATA_FILE path
        ml_df = pd.read_csv(ML_DATA_FILE)
        if 'Norad_id' not in ml_df.columns and 'Norad_id' not in ml_df.index.name:
             if 'Norad_id' in ml_df.index.name:
                 ml_df.reset_index(inplace=True)
             else:
                 if ml_df.columns[0].lower().startswith('unnamed'):
                     ml_df.rename(columns={ml_df.columns[0]: 'Norad_id'}, inplace=True)
                 else:
                      raise ValueError("Cannot find 'Norad_id' column or index in ML file.")

        ml_df['Norad_id'] = ml_df['Norad_id'].astype(int)
        satellite_features_series = ml_df[ml_df['Norad_id'] == norad_id]

        if satellite_features_series.empty:
            print(f"Info: No feature data found for NORAD ID {norad_id} in {ML_DATA_FILE}. Will plot without residual info.")
        else:
            satellite_features = satellite_features_series.iloc[0].to_dict()

    except FileNotFoundError:
        print(f"Warning: ML data file not found at {ML_DATA_FILE}. Plotting without residual info.")
    except Exception as e:
        print(f"Warning: Error reading {ML_DATA_FILE}: {e}. Plotting without residual info.")

    # --- Load Original TLE Data ---
    tle_file_path = None
    possible_filenames = [f"{norad_id}.csv", f"{norad_id}_tle_data.csv"] # Add other patterns if needed
    for fname in possible_filenames:
        temp_path = os.path.join(TLE_DATA_FOLDER, fname)
        if os.path.exists(temp_path):
            tle_file_path = temp_path
            break

    if tle_file_path is None:
         print(f"Error: Original TLE data file not found for NORAD {norad_id} in {TLE_DATA_FOLDER} (tried {possible_filenames})")
         return

    try:
        df_orig = pd.read_csv(tle_file_path)
        if df_orig.empty:
            print(f"Error: Original TLE file is empty: {tle_file_path}")
            return

        df_orig['Epoch'] = pd.to_datetime(df_orig['Epoch'])
        df_orig = df_orig.set_index('Epoch').sort_index() # Ensure sorted by time

        # Keep only necessary columns for plotting and time calculation
        cols_to_keep = [p for p in PARAMS_TO_PLOT if p in df_orig.columns]
        if not cols_to_keep:
             print(f"Error: None of the PARAMS_TO_PLOT found in {tle_file_path}")
             return

        # Calculate time_days relative to the start of this object's data
        time_seconds = (df_orig.index - df_orig.index.min()).total_seconds()
        time_days = time_seconds / (24.0 * 3600.0)
        df_orig['time_days'] = time_days

    except Exception as e:
        print(f"Error reading original TLE file {tle_file_path}: {e}")
        return

    # --- Generate a Separate Plot for each parameter ---
    plot_count = 0
    for param in PARAMS_TO_PLOT:
        if param not in df_orig.columns:
             print(f"Skipping {param}: Column not found in {tle_file_path}")
             continue

        # Create a temporary df for this parameter, dropping NaNs specifically
        df_param = df_orig[[param, 'time_days']].dropna()

        if len(df_param) < MIN_DATA_POINTS_FOR_PLOT:
            print(f"Skipping {param}: Insufficient valid data points ({len(df_param)} < {MIN_DATA_POINTS_FOR_PLOT}).")
            continue

        # Create a new figure and axes for each parameter
        fig, ax = plt.subplots(figsize=(12, 7))

        original_y = df_param[param].values
        # time_days should already be sorted because df_orig index was sorted
        time_days_clean = df_param['time_days'].values
        # Get the corresponding Epoch values for plotting x-axis
        epochs_clean = df_param.index

        try:
            # --- Re-fit the LOESS curve for plotting ---
            # Use the configured frac and it values
            # is_sorted=True assumes time_days_clean is sorted
            smoothed_output = lowess(original_y, time_days_clean,
                                     frac=LOESS_FRAC,
                                     it=LOESS_ITER,
                                     is_sorted=True,
                                     return_sorted=True)

            # Extract smoothed y values. The corresponding x-values (time) are in smoothed_output[:, 0]
            # but epochs_clean should align correctly because input was sorted.
            fitted_y = smoothed_output[:, 1]

            # Try to get residual std dev from loaded features
            residual_std = np.nan # Default
            if satellite_features:
                # Assume feature name is consistent with extractor script
                residual_feature_name = f'{param}_smooth_residual_stddev'
                if residual_feature_name in satellite_features:
                    residual_std = satellite_features[residual_feature_name]

            # Plotting
            ax.plot(epochs_clean, original_y, marker='.', linestyle='None', markersize=5, label='Original Data', alpha=0.6, color='steelblue')
            # Use the epochs corresponding to the original data points for the x-axis
            ax.plot(epochs_clean, fitted_y, color='red', linestyle='-', linewidth=2, label=f'LOESS Fit (frac={LOESS_FRAC}, it={LOESS_ITER})') # <-- Updated label
            ax.set_ylabel(param)
            ax.set_xlabel('Epoch (UTC)')

            title_str = f"NORAD {norad_id}: {param}"
            if not np.isnan(residual_std):
                 title_str += f" (Feature Residual StdDev: {residual_std:.4g})"
            ax.set_title(title_str)

            ax.legend()
            ax.grid(True, which='both', linestyle=':', linewidth=0.5)
            plt.xticks(rotation=30, ha='right')
            plt.tight_layout()
            plt.show(block=False) # Show plot without blocking others
            plot_count += 1

        except Exception as e:
            print(f"Error plotting {param} for {norad_id}: {e}")
            plt.close(fig) # Close the figure if plotting failed
            continue

    if plot_count > 0:
        print(f"\nGenerated {plot_count} separate plots for NORAD ID {norad_id}.")
        print("Close plot windows to continue or enter 'quit'.")
    else:
        print(f"\nNo plots generated for NORAD ID {norad_id} due to data issues or missing parameters.")


if __name__ == "__main__":
    plt.ion() # Turn on interactive mode

    while True:
        norad_id_input = input("Enter NORAD ID to plot (or 'quit' to exit): ")
        if norad_id_input.lower() == 'quit':
            break
        # --- Call the renamed function ---
        plot_loess_fit_vs_original_separate(norad_id_input)

        if plt.get_fignums():
             print("Waiting for plots to be closed or next input...")
             # plt.show() without block=True in interactive mode often doesn't pause reliably.
             # A simple wait loop or just relying on the next input prompt might be sufficient.
             # For a more robust pause, you might need GUI event loop integration,
             # but let's keep it simple for now. The next input prompt effectively pauses.
             plt.pause(0.1) # Small pause to allow rendering

    print("Exiting script.")
    plt.ioff() # Turn off interactive mode